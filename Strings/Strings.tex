\documentclass[12pt, letterpaper, twoside]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath, amsfonts, amssymb, amsthm}
\usepackage[left = 2cm, right = 2cm, top = 2cm, bottom = 2cm]{geometry}

\title{Strings.\\
	  \large Material de referencia.}
\author{}
\date{} 

%Estilo de la página
\usepackage{fancybox, fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE,RO]{\small{\leftmark}}
\fancyfoot[CE,CO]{\thepage}
\renewcommand{\headrulewidth}{2 pt}

%Imagenes
\usepackage{graphicx}
\graphicspath{{Imagenes/}}

%Estilo del codigo
\usepackage{listings}
\usepackage[dvipsnames]{xcolor}
\lstset{  
	language         = C++, 
	xleftmargin      = 1 cm,
	numbers          = left,
	numberstyle      = \tiny\textbf,	
	basicstyle       = \footnotesize,
	keywordstyle     = \color{blue},
	directivestyle   = \color{Green},
	commentstyle     = \color{purple},
	stringstyle      = \color{blue},
	showstringspaces = false,
	breaklines       = true,
}

%Documento
\begin{document}

\maketitle

\tableofcontents

\newpage

\section{Arreglo Z.}

Consideremos un string $s$. El arreglo Z de $s$ es un arreglo de enteros que guarda la longitud del substring más largo que empieza en la posición $i$ y es prefijo de $s$. 

En particular, podemos encontrar todas las ocurrencias de un patrón $P$ en un texto $T$ calculando el arreglo Z del string $P + \diamond + T$, donde $\diamond$ es algún carácter que no aparece ni en $P$ ni en $T$.

\subsection{Implementación}

Complejidad: $O(|P| + |T|)$.

\lstinputlisting[firstline = 6]{Z-Array.cpp} \medskip

\begin{tabular}{|p{7cm}|p{7cm}|}
\hline
\textbf{Entrada} & \textbf{Salida}\\ \hline
AABAACAADAABAABA & Patron encontrado en la posicion 0\\
AABA             & Patron encontrado en la posicion 9\\
                 & Patron encontrado en la posicion 12\\ \hline
\end{tabular}

\newpage

\section{Aho Corasick.}

Consideremos un texto $T$ y una lista de patrones $P_1, \ldots, P_n$. Queremos encontrar todas las ocurrencias de estos patrones en el texto.

El algoritmo de Aho Corasick resuelve este problema implementando un Trie sobre los patrones. Adicionalmente, cada vértice posee una nueva arista que representa el sufijo más largo del camino actual que es prefijo de algún patrón.

\subsection{Implementación}

Complejidad: $O(|T| + |P_1| + \ldots + |P_n| + \#Ocurrencias)$.

\lstinputlisting[firstline = 7]{Aho-Corasick.cpp} \medskip

\begin{tabular}{|p{7cm}|p{7cm}|}
\hline
\textbf{Entrada} & \textbf{Salida}\\ \hline
abcdabccabbacefdabc & abc aparece en la posicion 0\\
4                   & bcd aparece en la posicion 1\\
abc                 & abc aparece en la posicion 4\\
ca                  & ca aparece en la posicion 7\\
bcd                 & ef aparece en la posicion 13\\
ef                  & abc aparece en la posicion 16\\ \hline
\end{tabular}

\newpage

\section{Arreglo de sufijos.}

Consideremos un string $s$. El arreglo de sufijos de $s$ es un arreglo de enteros que guarda las posiciones iniciales de los sufijos de $s$ en orden lexicográfico.

\subsection{Implementación}

Complejidad: $O(|s|\log |s|)$.

\lstinputlisting[firstline = 6]{Suffix-Array.cpp} \medskip

\begin{tabular}{|p{7cm}|p{7cm}|}
\hline
\textbf{Entrada} & \textbf{Salida}\\ \hline
banana & 5 a\\
       & 3 ana\\
       & 1 anana\\
       & 0 banana\\
       & 4 na\\
       & 2 nana\\ \hline
\end{tabular}

\newpage

\end{document}